#+hugo_base_dir: ~/notes/
#+hugo_section: docs/algorithm
#+title: Project Euler

** 1. Multiples of 3 or 5
#+begin_quote
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\\
Find the sum of all the multiples of 3 or 5 below 1000.
#+end_quote
#+begin_src C++
  #include <iostream>

  int main() {
      int ans = 0;
      for (int i = 0; i < 1000; i++) {
	  if (i % 3 == 0 || i % 5 == 0) {
	      ans += i;
	  }
      }
      std::cout << ans << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 233168

** 2. Even Fibonacci Numbers
#+begin_quote
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
\[1,2,3,5,8,13,21,34,55,89,...\]
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
#+end_quote
#+begin_src C++
  #include <iostream>

  int main() {
      int prev = 1, curr = 2, ans = 0;
      while (curr <= 4e6) {
	  if (curr % 2 == 0) {
	      ans += curr;
	  }
	  int t = prev;
	  prev = curr;
	  curr = t + curr;
      }
      std::cout << ans << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 4613732

** 3. Largest Prime Factor
#+begin_quote
The prime factors of 13195 are 5, 7, 13 and 29.\\
What is the largest prime factor of the number 600851475143?
#+end_quote
#+begin_src C++
  #include <iostream>

  int main() {
      long long n = 600851475143;
      int i = 2;
      while (i * i < n) {
	  while (n % i == 0) {
	      n /= i;
	  }
	  i += i > 2 ? 2 : 1;
      }
      std::cout << n << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 6857

** 4. Largest Palindrome Product
#+begin_quote
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.\\
Find the largest palindrome made from the product of two 3-digit numbers.
#+end_quote
\[\begin{aligned}
abccba&=10^5a+10^4b+10^3c+10^2c+10b+a\\
&=100001a+10010b+1100c\\
&=11(9091a+910b+100c)
\end{aligned}\]
#+begin_src C++
  #include <iostream>
  #include <string>

  bool isPalindrome(int x) {
      std::string s = std::to_string(x);
      int i = 0, j = s.size() - 1;
      while (i < j) {
	  if (s[i] != s[j]) {
	      return false;
	  }
	  i++, j--;
      }
      return true;
  }

  int main() {
      int maxAns = 0;
      for (int i = 100; i <= 999; i++) {
	  for (int j = 100; j <= 999; j++) {
	      if ((i * j) % 11 == 0 && isPalindrome(i * j)) {
		  maxAns = std::max(maxAns,i * j);
	      }
	  }
      }
      std::cout << maxAns << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 906609

** 5. Smallest multiple
#+begin_quote
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\\
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
#+end_quote
#+begin_src C++
  #include <iostream>

  int gcd(int a, int b) {
      if (a % b == 0) return b;
      return gcd(b, a % b);
  }

  int main() {
      long long ans = 1;
      for (int i = 1; i <= 20; i++) {
	  ans = ans * i / gcd(ans, i);
      }
      std::cout << ans << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 232792560

** 6. Sum Square Difference
#+begin_quote
The sum of the squares of the first ten natural numbers is,
\[1^2+2^2+\ldots+10^2=385\]
The square of the sum of the first ten natural numbers is,
\[(1+2+\ldots+10)^2=55^2=3025\]
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025-385=2640\\
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
#+end_quote
#+begin_src C++
  #include <iostream>

  int main() {
      int ans = 0;
      int n = 100;
      int s = n * (1 + n) / 2;
      for (int i = 1; i <= n; i++) {
	  ans += i * (s - i);
      }
      std::cout << ans << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 25164150

** 7. 10001st prime
#+begin_quote
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\\
What is the 10 001st prime number?
#+end_quote
一般而言，对于第 \(n\) 个素数，满足以下不等式：
\[ln(nln(n))-1<\frac{p_n}{n}<ln(nln(n))\]
#+begin_src C++
  #include <iostream>
  #include <vector>
  #include <cmath>

  int main() {
      int n = 10001;
      int upperBound = ceil(n * log(n * log(n)));
      std::vector<int> primes;
      std::vector<int> st(upperBound + 1);
      for (int i = 2; i <= upperBound; i++) {
	  if (st[i] == 0) {
	      primes.push_back(i);
	  }
	  for (int j = 0; primes[j] <= upperBound / i; j++) {
	      st[primes[j] * i] = 1;
	      if (i % primes[j] == 0) break;
	  }
      }
      std::cout << primes[n - 1] << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 104743

** 8. Largest product in a series
#+begin_quote
The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
#+begin_center
73167176531330624919225119674426574742355349194934\\
96983520312774506326239578318016984801869478851843\\
85861560789112949495459501737958331952853208805511\\
12540698747158523863050715693290963295227443043557\\
66896648950445244523161731856403098711121722383113\\
62229893423380308135336276614282806444486645238749\\
30358907296290491560440772390713810515859307960866\\
70172427121883998797908792274921901699720888093776\\
65727333001053367881220235421809751254540594752243\\
52584907711670556013604839586446706324415722155397\\
53697817977846174064955149290862569321978468622482\\
83972241375657056057490261407972968652414535100474\\
82166370484403199890008895243450658541227588666881\\
16427171479924442928230863465674813919123162824586\\
17866458359124566529476545682848912883142607690042\\
24219022671055626321111109370544217506941658960408\\
07198403850962455444362981230987879927244284909188\\
84580156166097919133875499200524063689912560717606\\
05886116467109405077541002256983155200055935729725\\
71636269561882670428252483600823257530420752963450\\
#+end_center
Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
#+end_quote
#+begin_src C++
  #include <iostream>
  #include <vector>
  #include <string>
  #include <algorithm>

  int main() {
      std::string s = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";
      std::vector<long long> res;
      for (int i = 0; i < s.size() - 12; i++) {
	  long long t = 1;
	  for (int j = 0; j < 13; j++) {
	      t = t * (s[i + j] - '0');
	  }
	  res.push_back(t);
      }
      std::cout << *max_element(res.begin(), res.end()) << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 23514624000

** 9. Special Pythagorean triplet
#+begin_quote
A Pythagorean triplet is a set of three natural numbers, \(a<b<c\), which,
\[a^2+b^2=c^2.\]
For example, \(3^2+4^2=9+16=25=5^2\).\\
There exists exactly one Pythagorean triplet for which \(a+b+c=1000\).\\
Find the product \(abc\).
#+end_quote
\[\begin{aligned}
a^2+b^2&=(1000-a-b)^2\\
&=1000^2+a^2+b^2-2000a-2000b+2ab\\
\Rightarrow500*1000&=1000a+1000b-ab\\
b&=\frac{500*1000-1000a}{1000-a}
\end{aligned}\]
#+begin_src C++
  #include <iostream>

  int main() {
      int ans = 0;
      for (int a = 1; a < 333; a++) {
	  if ((500000 - 1000 * a) % (1000 - a) == 0) {
	      int b = (500000 - 1000 * a) / (1000 - a);
	      ans = a * b * (1000 - a - b);
	      break;
	  }
      }
      std::cout << ans << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 31875000

** 10. Summation of Primes
#+begin_quote
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\\
Find the sum of all the primes below two million.
#+end_quote
#+begin_src C++
  #include <iostream>
  #include <numeric>
  #include <vector>

  int main() {
      int n = 2e6;
      std::vector<int> primes;
      std::vector<int> st(n + 1, 0);
      for (int i = 2; i <= n; i++) {
	  if (st[i] == 0) {
	      primes.push_back(i);
	  }
	  for (int j = 0; primes[j] <= n / i; j++) {
	      st[primes[j] * i] = 1;
	      if (i % primes[j] == 0) break;
	  }
      }
      std::cout << std::accumulate(primes.begin(), primes.end(), (long long)0)
		<< std::endl;
      return 0;
  };
#+end_src

#+RESULTS:
: 142913828922

** 11. Largest Product in a Grid
#+begin_quote
In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
#+begin_center
#+begin_export html
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br/>
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br/>
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br/>
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br/>
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br/>
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br/>
32 98 81 28 64 23 67 10 <font color="#FF0000">26</font> 38 40 67 59 54 70 66 18 38 64 70<br/>
67 26 20 68 02 62 12 20 95 <font color="#FF0000">63</font> 94 39 63 08 40 91 66 49 94 21<br/>
24 55 58 05 66 73 99 26 97 17 <font color="#FF0000">78</font> 78 96 83 14 88 34 89 63 72<br/>
21 36 23 09 75 00 76 44 20 45 35 <font color="#FF0000">14</font> 00 61 33 97 34 31 33 95<br/>
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br/>
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br/>
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br/>
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br/>
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br/>
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br/>
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br/>
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br/>
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br/>
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48<br/>
#+end_export
#+end_center
The product of these numbers is 26 × 63 × 78 × 14 = 1788696.\\
What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
#+end_quote
#+begin_src C++
  #include <iostream>
  #include <vector>
  #include <string>
  #include <algorithm>

  int main() {
      std::string s = "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\n"
		      "49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\n"
		      "81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\n"
		      "52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\n"
		      "22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\n"
		      "24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\n"
		      "32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\n"
		      "67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\n"
		      "24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\n"
		      "21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\n"
		      "78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\n"
		      "16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\n"
		      "86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\n"
		      "19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\n"
		      "04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\n"
		      "88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\n"
		      "04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\n"
		      "20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\n"
		      "20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\n"
		      "01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\n";
      std::vector<std::vector<int>> data;
      std::vector<int> tmp;
      std::string t;
      for (int i = 0; i < s.size(); i++) {
	  if (s[i] == '\n') {
	      tmp.push_back(std::stoi(t));
	      t.clear();
	      data.push_back(tmp);
	      tmp.clear();
	  }
	  else if (s[i] == ' ') {
	      tmp.push_back(std::stoi(t));
	      t.clear();
	  }
	  else {
	      t += s[i];
	  }
      }
      int m = data.size(), n = data[0].size();
      std::vector<int> ans;
      for (int i = 0; i < m - 3; i++) {
	  for (int j = 0; j < n - 3; j++) {
	      int prod = 1;
	      for (int k = 0; k < 4; k++) {
		  prod *= data[i + k][j + k];
	      }
	      ans.push_back(prod);
	  }
      }
      for (int i = 3; i < m; i++) {
	  for (int j = 0; j < n - 3; j++) {
	      int prod = 1;
	      for (int k = 0; k < 4; k++) {
		  prod *= data[i - k][j + k];
	      }
	      ans.push_back(prod);
	  }
      }
      for (int i = 0; i < m; i++) {
	  for (int j = 0; j < n - 3; j++) {
	      int prod = 1;
	      for (int k = 0; k < 4; k++) {
		  prod *= data[i][j + k];
	      }
	      ans.push_back(prod);
	  }
      }
      for (int i = 0; i < m - 3; i++) {
	  for (int j = 0; j < n; j++) {
	      int prod = 1;
	      for (int k = 0; k < 4; k++) {
		  prod *= data[i + k][j];
	      }
	      ans.push_back(prod);
	  }
      }
      std::cout << *std::max_element(ans.begin(), ans.end()) << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 70600674

** 12. Highly Divisible Triangular Number
#+begin_quote
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
\[1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\]
Let us list the factors of the first seven triangle numbers:
\[\begin{aligned}
\mathbf{1}&:1\\
\mathbf{3}&:1,3\\
\mathbf{6}&:1,2,3,6\\
\mathbf{10}&:1,2,5,10\\
\mathbf{15}&:1,3,5,15\\
\mathbf{21}&:1,3,7,31\\
\mathbf{28}&:1,2,4,7,14,28
\end{aligned}\]
We can see that 28 is the first triangle number to have over five divisors.\\
What is the value of the first triangle number to have over five hundred divisors?
#+end_quote
#+begin_src C++
  #include <iostream>
  #include <vector>
  #include <unordered_map>

  int getDivisorNum(int x) {
      std::unordered_map<int, int> primes;
      for (int i = 2; i <= x / i; i++) {
	  if (x % i == 0) {
	      while (x % i == 0) {
		  primes[i]++;
		  x = x / i;
	      }
	  }
      }
      if (x > 1) primes[x]++;
      int ans = 1;
      for (auto p : primes) {
	  ans = ans * (p.second + 1);
      }
      return ans;
  }

  int main() {
      int ans = 0, i = 1, n = 500;
      while (true) {
	  ans = i * (i + 1) / 2;
	  if (getDivisorNum(ans) >= n) {
	      break;
	  }
	  i++;
      }
      std::cout << ans << std::endl;
      return 0;
  }
#+end_src

#+RESULTS:
: 76576500

